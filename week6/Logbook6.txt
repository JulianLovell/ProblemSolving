JULIAN'S LOGBOOK

Problem 1 - GoodHours
Design Ideas: 
This one took me a little while to fully think through, but it seems easy enough. 
I can loop through every minute between beforeTime and afterTime, after converting the times into minutes since midnight for easier iterations. 
For each minute, we just extract the digits from hours and minutes and check if the time is good by trying three different splits of the digits like hours and minutes. 
If any split results in equal products, it therefore counts as a good time.

I can handle a case where afterTime is earlier than beforeTime by adding 24 hours to afterTime. 
And like other questions i will keep a counter for good times and return the count at the end.

Troubleshooting:
Had no issues with the first implementation. I expected this to work as a spent a bit longer brainstorming the problem. Was fairly simple to do.

Reflection:
My code definetly wasn't optimised and i could have used seperate functions to write this better, however in this class i prefer to try to keep everything in the one function just because i find it a bit easier to read
through/ debug.


Problem 2 - BlackAndWhiteSolitaire
Design Ideas:
This one seems pretty straightforward, i can just us a for loop and iterate through the given string, i can then have a counter variable to track how many cards are flipped and then a variable within the string 
tracking the colour of the current/previous card. I if the current matches the previous i will ++counter and iterate to the next, setting the previous value to the correct colour. The only situation where this wouldn't
work i imagine, is a case where the optimal number of flips requires the first to be flipped instead of starting the pattern from there. A lazy solution to this can be to just do this whole thing twice, once for each
possible colour for the starting card, and then just return the minimum counted variable out of the two. Another solution could be doing something like counting through how many black/white cards there already are
and maybe there is some sort of connection where if there are already more white than black cards it is more efficient to start with white. However i will stick with my initial thought process. 

Troubleshooting:
My first implementation didn't account for the first card being incorrect for the optimal solution, however i just wanted to make sure my loop logic was correct. 
I also spelt solitiare wrong every time i wrote it which wasn't very helpful and caused the compile to fail.
My first attempt didn't even run on gradescope, which i sort of expected as it was a very lazy initial implementation. I have re done it, this time also including the second loop through and expect this version to work.
That implementation also didn't compile as i have now realised when correcting the spelling of solitaire i actually did have it spelled write and rewrote it incorrectly. This means i rewrote all my code unnecessarily.

Reflection:
My first proper attempt passed the first time, however it took more tries than it should have. Ive learned from this that i need to be way more careful in writing out the function and file names. Taking a lazy approach from the start, while my code was fine,
led to me making unnecessary issues elsewhere, which is a mistake i made in prac exam 1 as well.


Problem 3 - ColorfulRabbits
Design Ideas:

Troubleshooting:

Reflection:


Problem 4 - NiceOrUgly (BONUS)