JULIAN'S LOGBOOK

Problem 1 - ChangingString
Initial Thoughts:
I had to re-read the question many times before I think i now understand what it is asking for the problem. 
The first thing that comes to mind is assigning each letter to its corresponding number first and then just working with the numbers instead by returning the A[i] - B[i] for example.
I remember in another class converting letters to numbers using their ASCII values so i might look into doing that.
From there i can find the differences and store these in a vector, then just sort and perform the operation on the K biggest to make their distance 0, which i think is what it is asking.
After doing that i just find the new sum of the distances and return.

Reflection:
So it turns out that C++ inherently represents characters by their ASCII values for math operations, so that means a - b for example can work. I didn't know this, or at least forgot, so that is interesting and helpful.
After first attempt and submission i realised that i wasn't doing it correctly. Just setting the largest K differences to 0 isnt the same as changing K characters in the string.


Problem 2 - MooingCows
Initial Thoughts:
The steps i think i need to take for solving this problem are: find cow positions, calculate the disatisfaction then minimise that disatisfaction. Like most other problems i should start by creating a new list
to store the cow positions and then i can loop through looking for 'C' and storing that location. I will begin by implementing this.

Reflection:
I kept going after that beginning code and added another set of loops to calc the disatisfaction if a cow moos, then finally just updating the new min satisfaction. 

Problem 3 - Reppity
Initial Thoughts:
I picked this one to do mainly because i liked the name. In terms of solving it, i think i will need to do something to iterate over all of the possible substring lengths. The first thing that comes to mind is
to begin with the longest possible substring and then iterate through looking for a match, shorterning it until i do find a match, however this seems very inefficient. I will try this first. I should also make sure to
return 0 at the end in the event of none being found.

Reflection:
My first attempt passed the first test case, however failed the second because i didnt properly handle overlapping. I can fix this by changing how i am looking at the possible substrings and the overlap check. Ok that worked,
and was actually simpler than my first version anyway.

Problem 4 - EggCartons
Initial Thoughts:
This problem seems pretty straightforward. I can just iterate through with the largest possible increments (8) stopping once the cartons exceed n and then swapping in the smaller size cartons 1 by 1, i believe this is a greedy approach.
I can also immediately return -1 for any odd number as that is not possible to get exactly given the carton sizes.

Problem 5 - AlternateColors
Initial Thoughts:
I basically need to simulate the robot destroying the balls and can do this by just iterating through performing each of the checks and deleting the corresponding ball, then just returning the colour of the deleted ball at k.

Reflection:
My first attempt seemed to be getting stuck in a loop. I am first going to assume that this is occuring on test cases where K may be greater than the number of balls available.
