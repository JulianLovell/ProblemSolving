JULIAN'S LOGBOOK


Problem 1 - MagicSpell
Initial Thoughts: 
I think for this one i can create a second temp string, using this, i can iterativley go through the given characters, storing the A and Z's every time i find one and in the order i find them. Then i just iterate through
this temp string alongside the given spell and each time i encounter an A or Z again in the given spell i just replace it with the A or Z but drawing from the back of the temp, or i could reverse temp and just draw from the front.

Reflections:
This was pretty simple, which would be expected from a warmup question to be fair.


Problem 2 - RugSizes
Initial Thoughts:
For this i think i can start counting up from (1 x area), then (2 x area-1) until i reach area/2, going past that would only create duplicates. I should also check at each iteration if both values are even, and if they
are then i just skip to the next. I will implement this first and see if i need to make any changes from there.

Reflections:
Another simple one, but i am coming up with the solutions faster and feeling more confident in coding them since week 1 so im feeling good about my progress. 


Problem 3 - TimeTravellingCellar
Initial Thoughts:
This one seemed pretty interesting. There are a few simple rules i can follow while iteratively searching through a nested loop of profit[i] and decay[j]. In this totalProft will equal profit[i] - decay[j]. 
Also since i cannot advance and decay in the same cellar, i cannot equal j so i can just skip this iteration when i encounter it. Using this method i can just store and dynamically update a bestProfit value.

Reflections:
That problem was pretty simple, i had to take two attempts as i had written in the function call incorrectly, but everything else in the program worked perfectly. 


Problem 4 - MonstersValley2 (Bonus)
Initial Thoughts:
For this weeks problems i have actually remembered that the bonus gives 200 marks so this is the last one for this week. I also notice that the killer rabbit has a scariness of 10 which is a reference to Monty Python.
This problem seems like an optimisation problem as in some scenarios it will be better to just pay of the scaryiest monsters while in others i should try to assemble mutliple first and then just walk past.
Some conditions to take note of but may or may not need to be directly coded are that if the elements of dread[] progressively grow larger i will need to buy each one, also if the largest value is first then 
i can just buy the first and not any others. I might start by just implementing it to bribe any monster that exceeds the party's scariness and walk past otherwise, although i presume that there will be cases where 
it will be more optimal to bribe a monster who's scariness is only needed later. Another idea is that i can solve this dynamically by trying each combination and saving the cheapestParty, i guess this is the correct
way to solve it but it feels like cheating as using this method means that Manao can see the future.

Reflections: