
JULIAN'S LOGBOOK

Problem 1 - MinimalDifference
Design Ideas:
Starting at integer A, iterate through the digit sums up until int B is reached. At each iteration check if it is closer to C and if so, then update that as the closest. 
If at any point, the digit sum == int C, then return the current number we are on, since we are iterating up, the smallest will always be reached first.
The hard part i think is finding the digit sum, i have done this is the past using a method with a modulus, which i will need to try to remember again.

Troubleshooting:
After the first submission i notice that my current iteration fails when C > B, this is because i am trying to find the digit sum closest to C, not the digit sum closest to 
the digit sum of C. This should be an easy fix by just finding the digit sum of c at the start and then using that in the if statement checks rather than C.

For all of these problems, i am carrying on from progress i made in the initial workshop session where i started these. Looking at this one again, i was very close however there were some issues i need to address.
Firstly, i was using the wrong comparison within my else if function, secondly my code is very inefficient by recalculating the digit sum each time. I think i will take a lot of what i already have, but re write
a lot of it and add a helper function to handle the digit sum calculation. This should improve everything and get it working.

Reflection:
After the first bit of troubleshooting, i got this working straight away. I was right in my assumption of the errors and i am glad i was able to get some good practice with a working helper function, which i normally
am afraid to use.

Problem 2 - VeryInterestingMovie
Design Ideas:
Seems like i can just iterate through each element of seats, using a counter on how many students are able to fit. Then continuing this into the other elements too. 
The hard part which i know there will be test cases for, is handling the unavailable seats. I could just start from the first available seat but there will be cases where it
is probably optimal to skip that one and start from the next. I am not quite sure how i will handle this, so i am going to start with the basis of the code and see how it goes
from there, i might be overthinking this and that will just work.

Troubleshooting:
Like the previous, i am picking this up from the workshop progress i made. I dont think i had a properly compiliing program, but what i did already have was logically correct. This means all i need to fix 
is some syntax error related issues.

Upon another look i had some more issues. I also had some mistakes with incorrect seat indexing, which i just corrected by using seats[i][j] to properly access the seats.
Finally, i am also going to mostly re write this one as i dont remember my exact thoughts when last working on this in class. I will again use a lot of it as a base but write from the start again to follow my thought process.

Reflection:
With the re write this problem was pretty simple. I had a good understanding of what to do once i got the general logic. I used a greedy approach, which involved placing the students and then immediately skipping seats.


Problem 3 - FairWorkload
Design Ideas:
So from what i understand, the problem is to find the optimal partitioning of the cabinets, so no working gets too many folders. To do this i think i can use a binary search approach. 
Each midpoint could then have some sort of check.
To refine this thought process: the min in the binary search will be the max number of folders in any cabinet, the max is the total amount of folders, and then using the binary search i can 
look to find the smallest value of the max number of folders a worker can do. Each midpoint could have a check to see ig iy is possible to seperate the cabinets so that no wokrer has more than the 'midpoint' amount of folders.
I think this is also another opportunity to use a helper function, in this case it will handle the midpoint check.

Troubleshooting:
I got a bit lost while solving this one at a few different points. However nothing that fully stopped my progress. I knew roughly what i wanted to do but not the specifics on how to approach it, which 
is clear from what i wrote in design ideas. 

Reflection:
I think this one ended up being great practice for a few different things. I got more practice on a greedy appraoch which i am pretty comfortable with now. But i also got to use a binary search, as well as a new 
library which i do not think i have used before. Overall, despite getting a bit confused i am happy with my work on this problem, however in the future i think i need to make sure i write out a clearer initial plan.


Problem 4 - PrefixFreeSets (BONUS)
Design Ideas:
I think i can just use a brute force method where i compare every word against every other word. I can just iterate through the words, checking if each is a prefix of another and just excluding that from
the final word count. This way i can just build up the largest prefix free set.

Troubleshooting:

Reflection:

