JULIAN'S LOGBOOK


Problem 1 - Arrows
Initial Thoughts:
Initially i misunderstood the question and thought it was asking to return the number of arrows not just the longest one. 
Now understanding this, i would say the first step will be to identify the possible arrows (<-, <=, ->, =>), and then possibly iterate through each when found, checking its length. 
I figure that while doing that i can just have another variable called something like longestFound and i can check the length of the arrow we are currently on against the longest so far, updating if necessary.

Reflection:
My first implementation did pretty well however there are two cases i seem to not be handling correcty, which i did expect. Firstly, I am not correctly counting arrows that go from '-' to '=' as that second
character should still be counted as a continuation of the arrow. Secondly i was not counting the arrow head as an arrow so for cases like '<<<<' it was returning 0 instead of 1. These should be simple fixes by changing
how i search for the arrow characters and changing the initial length value on left facing arrows. On the new implementation i was incorrectly count '>' at the end of the right facing arrows. Upon looking at fixing this
i re-read the description and decided to take a slightly different approach. I re-wrote some of the program keeping parts. This new approach makes more sense and should handle these different cases correctly without
adding new functions. I made a super small change fixing the check for updating the length of the current longest arrow, expecting it to only fix 1 or 2 test cases, but ive gotten full marks now so we're good to go.


Problem 2 - ExerciseMachine
Initial Thoughts:
I've chosen to do this one before actually reading it because i like going to the gym. After reading it, the only thing that comes to mind is possibly converting the time to be a single number such as seconds, which
would mean the largest number to work with would be 85999. I could then calculate every whole number percentage of that large number and return how many it is. That might be possible but i imagine highligy inefficient. However i will begin with that unless i think of something else.

Reflection:
I'm amazed my very first iteration worked. It was very straigth forward and short to write so ill take that. I wonder if that is the intended way to solve it as i imagine there is a far more efficient method.


Problem 3 - StrangeComputer
Initial Thoughts:
I imagine that i can iteration from the largest bit value, so starting from the left, and iterate until i encounter a character that does not match the character in that position of the given memory value. 
Then i just select that element and the number it should be then update the string to match. Then continue iterating through the updated string. I should also initialise the string to be all 0's.

Reflection:
Ok i got that on the first attempt too. I have found the 2 star difficulty questions far easier than the 1 star warmup Arrows question. That makes me think that my solution for arrows for far more complicated than 
necessary. Reflecting on this question, i was able to do it without actually generating any new string and instead just checking the currentbit value to the location in the given memory.


Problem 4 - QuickSums
Initial Thoughts:
If i am understanding this problem correclty. Then a number that can be used in an addition can be multiple consecutive elements within the string. So if the target number is 24 and the string is 1212, then it would
be 1 addition (12+12). Using this logic, i think i can iterate through the digits of the string, forming the largest number possible until it exceeds the target value, then i can use the largest number possible at each
step, reducing to smaller digits as required to make up the next addition. If i reach the end and find it was not possible then i can just return -1 as required.

Reflection:
I haven't been very confident with recursion from previous classes, however this problem felt like a good opportunity to get some practice. I kept the main ideas from my initial thoughts but implemented it recursively rather than
using loops like i would have probably tried to do.

Problem 5 - FewestFactors
Initial Thoughts:

Reflection:
